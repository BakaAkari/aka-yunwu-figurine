# 云雾API图像处理插件实施方案

## 1. 项目概述

### 1.1 功能描述
基于现有的 `aka-yunwu-figurine` 插件，新增"多风格图像处理"功能：
- 接收用户发送的图像
- 使用 Koishi 的 `h.select` 函数获取图像直链
- 调用云雾API的 `/fal-ai/nano-banana/edit` 图片编辑接口
- 支持4种核心风格的图像转换（变手办、变真人、角色设定、二次元）
- 支持用户自定义prompt进行图像处理
- 返回处理后的图像结果

### 1.2 技术栈
- **框架**: Koishi 4.x
- **语言**: TypeScript
- **API**: 云雾API (https://yunwu.ai)
- **接口**: `/fal-ai/nano-banana/edit` (图片编辑)

## 2. API接口规范

### 2.1 图片编辑接口

**接口地址**: `POST https://yunwu.ai/fal-ai/nano-banana/edit`

**请求参数**:
```json
{
  "prompt": "string",           // 图片编辑的提示词
  "image_urls": ["string"],     // 需要编辑的图片URL数组（必填）
  "num_images": 1               // 生成图片数量 (1-4)，默认值：1
}
```

**注意**：
- ⚠️ 字段名是 `image_urls`（复数），不是 `image_url`
- ⚠️ 类型是**数组**，即使只有一张图片也要用数组：`["url"]`
- ✅ 官方示例可以传入多张图片URL

**官方请求示例**:
```json
{
  "prompt": "make a photo of the man driving the car down the california coastline",
  "image_urls": [
    "https://storage.googleapis.com/falserverless/example_inputs/nano-banana-edit-input.png",
    "https://storage.googleapis.com/falserverless/example_inputs/nano-banana-edit-input-2.png"
  ],
  "num_images": 1
}
```

**响应格式**:
```json
{
  "status": "IN_QUEUE",
  "request_id": "uuid",
  "response_url": "string",
  "status_url": "string",
  "queue_position": 0
}
```

### 2.2 结果查询接口

**接口地址**: `GET https://yunwu.ai/fal-ai/nano-banana/requests/{request_id}`

**响应格式**:
```json
{
  "images": [
    {
      "url": "https://fal.media/files/...",
      "width": 1024,
      "height": 1024,
      "content_type": "image/jpeg"
    }
  ],
  "prompt": "编辑提示词"
}
```

## 3. 插件配置设计

### 3.1 新增配置项

```typescript
export const Config = Schema.object({
  // 现有配置...
  apiKey: Schema.string().description('云雾API密钥').required(),
  apiTimeout: Schema.number().default(120).description('API请求超时时间（秒）'),
  pollInterval: Schema.number().default(3).description('轮询间隔时间（秒）'),
  maxPollAttempts: Schema.number().default(40).description('最大轮询次数'),
  
  // 默认设置
  defaultNumImages: Schema.number()
    .default(1)
    .min(1)
    .max(4)
    .description('默认生成图片数量')
})
```

### 3.2 用户状态管理（简化版）

```typescript
// 不再需要复杂的 UserState 接口
// 只需要一个简单的 Map 跟踪活动任务
const activeTasks = new Map<string, string>()  // userId -> requestId
```

**优势**：
- ✅ 不需要管理等待状态
- ✅ 不需要管理超时时间
- ✅ 不需要管理频道ID
- ✅ 代码更简洁，状态更简单

## 4. Koishi 基础交互方法速查

> 参考：[Koishi官方文档](https://koishi.chat/zh-CN/guide/basic/)

本章节总结了Koishi官方推荐的基础交互方法，**本方案完全遵循这些官方方法实现**，避免使用不推荐的方式（如直接解析CQ码、使用console.log等）。

### 4.1 消息发送

```typescript
// 普通发送
await session.send('消息内容')

// 延时队列发送（推荐用于多条消息，避免刷屏）
await session.sendQueued('消息1')
await session.sendQueued('消息2')

// 清空发送队列
await session.cancelQueued()

// 广播消息到多个频道
await ctx.broadcast(['channelId1', 'channelId2'], '消息内容')

// 使用bot对象发送消息（主动发送）
await bot.sendMessage(channelId, '消息内容')
```

### 4.2 消息元素处理

```typescript
// 使用 h.select 选择元素（推荐）
const images = h.select(session.elements, 'img')
const imageUrl = images[0]?.attrs.src

// 发送图片
await session.send(h.image(url))

// 发送多个元素
await session.send([h.text('文字'), h.image(url)])
```

### 4.3 等待用户输入

```typescript
// 等待用户输入（带超时）
await session.send('请输入内容：')
const input = await session.prompt()
if (!input) return '输入超时'

// 自定义超时时间（毫秒）
const input = await session.prompt(30000) // 30秒
```

### 4.4 中间件

```typescript
// 中间件必须调用 next() 或返回值
ctx.middleware(async (session, next) => {
  // 检查条件
  if (condition) {
    await handleSomething(session)
    return // 不调用next()，阻止后续处理
  }
  
  return next() // 继续执行后续中间件和指令
})
```

### 4.5 指令系统

```typescript
// 定义指令
ctx.command('名称 <必选参数> [可选参数]', '描述')
  .option('opt', '-o <value:type> 选项描述')
  .usage('使用说明')
  .example('示例')
  .action(async ({ session, options }, arg1, arg2) => {
    // 指令逻辑
    return '返回消息'
  })
```

### 4.6 生命周期管理

```typescript
// 定时任务
ctx.setInterval(() => {
  // 定期执行的任务
}, 10000)

// 在插件卸载时清理（自动管理）
ctx.on('dispose', () => {
  // 清理资源
})
```

### 4.7 日志系统

```typescript
const logger = ctx.logger('plugin-name')

logger.debug('调试信息', { data })
logger.info('一般信息')
logger.success('成功信息')
logger.warn('警告信息')
logger.error('错误信息', error)
```

### 4.8 机器人对象 (Bot)

```typescript
// 从session获取bot对象
const bot = session.bot

// 从ctx获取特定bot
const bot = ctx.bots[`${platform}:${selfId}`]

// 使用bot对象主动发送消息（适用于异步任务、定时任务）
await bot.sendMessage(channelId, '消息内容')
await bot.sendMessage(channelId, h.image(url))
```

**何时使用bot对象而不是session**：
- ✅ 异步任务中（如轮询）：`bot.sendMessage()`
- ✅ 定时任务中：`bot.sendMessage()`
- ✅ 长时间等待后发送：`bot.sendMessage()`
- ❌ 指令action中立即回复：直接 `return` 或 `session.send()`

### 4.9 HTTP请求

```typescript
// GET请求
const data = await ctx.http.get(url, { headers: {} })

// POST请求
const data = await ctx.http.post(url, body, { 
  headers: {},
  timeout: 30000 
})
```

## 5. 核心功能实现

### 5.1 图片URL获取方法（改进版）

参考 `koishi-plugin-anime-trace` 的实现，使用更完善的图片获取方式：

```typescript
async function getImageUrl(img: any, session: Session): Promise<string | null> {
  let url: string | null = null
  
  // 方法1：从命令参数获取图片
  if (img) {
    url = img.attrs.src
    logger.debug('从命令参数获取图片', { url })
    return url
  }
  
  // 方法2：从引用消息获取图片
  let elements = session.quote?.elements
  if (elements) {
    const images = h.select(elements, 'img')
    if (images.length > 0) {
      url = images[0].attrs.src
      logger.debug('从引用消息获取图片', { url })
      return url
    }
  }
  
  // 方法3：等待用户发送图片
  await session.send('请在30秒内发送一张图片')
  const msg = await session.prompt(30000)
  
  if (!msg) {
    await session.send('等待超时')
    return null
  }
  
  // 解析用户发送的消息
  elements = h.parse(msg)
  const images = h.select(elements, 'img')
  
  if (images.length === 0) {
    await session.send('未检测到图片，请重试')
    return null
  }
  
  url = images[0].attrs.src
  logger.debug('从用户输入获取图片', { url })
  return url
}
```

**优势**：
- ✅ 支持命令参数直接传图：`图像处理 [图片]`
- ✅ 支持引用消息中的图片：回复包含图片的消息
- ✅ 支持等待用户输入：使用 `session.prompt()`
- ✅ 使用 `h.parse()` 解析消息内容
- ✅ 统一使用 `h.select()` 选择图片元素

**注意**：
- 使用 `session.prompt()` 替代中间件监听，更简洁
- 使用 `h.parse()` 解析用户发送的原始消息
- 图片元素类型是 `'img'`
- 图片URL属性是 `attrs.src`

### 5.2 任务状态管理（简化版）

```typescript
// 只需要跟踪正在进行的任务，不需要复杂的等待状态
const activeTasks = new Map<string, string>()  // userId -> requestId
```

### 5.3 多风格图像处理命令

```typescript
export default function apply(ctx: Context, config: Config) {
  const logger = ctx.logger('aka-yunwu-figurine')
  const activeTasks = new Map<string, string>()
  
  // 获取风格提示词（硬编码，不依赖配置）
  function getStylePrompt(style: string): string {
    const stylePrompts: Record<string, string> = {
      // 4个核心风格
      figurine: '将这张照片变成手办模型。在它后面放置一个印有图像主体的盒子，桌子上有一台电脑显示Blender建模过程。在盒子前面添加一个圆形塑料底座，角色手办站在上面。如果可能的话，将场景设置在室内',
      realistic: '生成一个真人女孩cosplay这张插画的写实照片，照片背景设置在真实街道',
      character_design: '为我生成人物的角色设定（Character Design）, 比例设定（不同身高对比、头身比等）, 三视图（正面、侧面、背面）, 表情设定（Expression Sheet） , 动作设定（Pose Sheet） → 各种常见姿势, 服装设定（Costume Design）',
      anime: '将这张图片变成新海诚风格, 日式赛璐珞的图片'
    }
    
    return stylePrompts[style] || stylePrompts.upscale
  }
  
  // 通用图像处理函数
  async function processImage(session: any, img: any, style: string, numImages?: number) {
    const userId = session.userId
    
    // 检查是否已有任务进行
    if (activeTasks.has(userId)) {
      return '您有一个图像处理任务正在进行中，请等待完成'
    }
    
    // 获取参数
    const prompt = getStylePrompt(style)
    const imageCount = numImages || config.defaultNumImages
    
    // 验证参数
    if (imageCount < 1 || imageCount > 4) {
      return '生成数量必须在 1-4 之间'
    }
    
    // 获取图片URL
    const imageUrl = await getImageUrl(img, session)
    if (!imageUrl) {
      return  // 错误信息已在 getImageUrl 中发送
    }
    
    logger.info('开始图像处理', { 
      userId, 
      imageUrl, 
      style,
      prompt, 
      numImages: imageCount 
    })
    
    // 调用图像编辑API
    await session.send(`开始处理图片（${style}风格）...`)
    
    try {
      const taskResponse = await callImageEditAPI(prompt, imageUrl, imageCount)
      activeTasks.set(userId, taskResponse.request_id)
      
      await session.send(
        `图像处理任务已提交！\n风格: ${style}\n任务ID: ${taskResponse.request_id}\n队列位置: ${taskResponse.queue_position}`
      )
      
      // 开始轮询任务状态
      const channelId = session.channelId
      if (!channelId) {
        activeTasks.delete(userId)
        return '无法获取频道信息'
      }
      
      pollImageEditStatus(
        taskResponse.request_id, 
        userId, 
        session.bot, 
        channelId
      ).finally(() => {
        activeTasks.delete(userId)
      })
      
    } catch (error) {
      activeTasks.delete(userId)
      logger.error('图像处理失败', { userId, error })
      return '图像处理失败，请重试'
    }
  }
  
  // 变手办风格命令
  ctx.command('变手办 [img:text]', '转换为手办风格')
    .option('num', '-n <num:number> 生成图片数量 (1-4)')
    .action(async ({ session, options }, img) => {
      return processImage(session, img, 'figurine', options?.num)
    })
  
  // 变真人风格命令
  ctx.command('变真人 [img:text]', '转换为真人风格')
    .option('num', '-n <num:number> 生成图片数量 (1-4)')
    .action(async ({ session, options }, img) => {
      return processImage(session, img, 'realistic', options?.num)
    })
  
  // 角色设定风格命令
  ctx.command('角色设定 [img:text]', '生成人物角色设定')
    .option('num', '-n <num:number> 生成图片数量 (1-4)')
    .action(async ({ session, options }, img) => {
      return processImage(session, img, 'character_design', options?.num)
    })
  
  // 二次元风格命令
  ctx.command('二次元 [img:text]', '转换为新海诚风格')
    .option('num', '-n <num:number> 生成图片数量 (1-4)')
    .action(async ({ session, options }, img) => {
      return processImage(session, img, 'anime', options?.num)
    })
  
  // 自定义prompt命令
  ctx.command('生成图像', '使用自定义prompt进行图像处理')
    .option('num', '-n <num:number> 生成图片数量 (1-4)')
    .action(async ({ session, options }) => {
      const userId = session.userId
      
      // 检查是否已有任务进行
      if (activeTasks.has(userId)) {
        return '您有一个图像处理任务正在进行中，请等待完成'
      }
      
      // 等待用户发送图片和prompt
      await session.send('请发送图片和prompt，格式：\n[图片] + 你的prompt描述\n\n例如：\n[图片] 让这张图片变成油画风格')
      
      const msg = await session.prompt(60000) // 60秒超时
      if (!msg) {
        return '等待超时，请重试'
      }
      
      // 解析消息内容
      const elements = h.parse(msg)
      const images = h.select(elements, 'img')
      const textElements = h.select(elements, 'text')
      
      // 检查是否有图片
      if (images.length === 0) {
        return '未检测到图片，请重新发送包含图片的消息'
      }
      
      // 提取prompt文本
      const prompt = textElements.map(el => el.attrs.content).join(' ').trim()
      if (!prompt) {
        return '未检测到prompt描述，请重新发送包含图片和文字描述的消息'
      }
      
      const imageUrl = images[0].attrs.src
      const imageCount = options?.num || config.defaultNumImages
      
      // 验证参数
      if (imageCount < 1 || imageCount > 4) {
        return '生成数量必须在 1-4 之间'
      }
      
      logger.info('开始自定义图像处理', { 
        userId, 
        imageUrl, 
        prompt, 
        numImages: imageCount 
      })
      
      // 调用图像编辑API
      await session.send(`开始处理图片（自定义prompt）...\nPrompt: ${prompt}`)
      
      try {
        const taskResponse = await callImageEditAPI(prompt, imageUrl, imageCount)
        activeTasks.set(userId, taskResponse.request_id)
        
        await session.send(
          `图像处理任务已提交！\nPrompt: ${prompt}\n任务ID: ${taskResponse.request_id}\n队列位置: ${taskResponse.queue_position}`
        )
        
        // 开始轮询任务状态
        const channelId = session.channelId
        if (!channelId) {
          activeTasks.delete(userId)
          return '无法获取频道信息'
        }
        
        pollImageEditStatus(
          taskResponse.request_id, 
          userId, 
          session.bot, 
          channelId
        ).finally(() => {
          activeTasks.delete(userId)
        })
        
      } catch (error) {
        activeTasks.delete(userId)
        logger.error('自定义图像处理失败', { userId, error })
        return '图像处理失败，请重试'
      }
    })
  
}
```

**改进说明**：
- ✅ 不再需要复杂的用户状态管理
- ✅ 不再需要中间件监听图片消息
- ✅ 不再需要超时管理定时器
- ✅ 支持命令参数直接传图：`图像处理 [图片]`
- ✅ 支持引用消息：回复包含图片的消息并执行命令
- ✅ 使用 `session.prompt()` 等待用户输入
- ✅ 代码更简洁，逻辑更清晰

### 5.4 图像编辑API调用

```typescript
async function callImageEditAPI(prompt: string, imageUrl: string, numImages: number = 1) {
  const requestData = {
    prompt,
    image_urls: [imageUrl],  // ⚠️ 注意：必须是数组，即使只有一张图片
    num_images: numImages
  }
  
  try {
    const response = await ctx.http.post(
      'https://yunwu.ai/fal-ai/nano-banana/edit',
      requestData,
      {
        headers: {
          'Authorization': `Bearer ${config.apiKey}`,
          'Content-Type': 'application/json'
        },
        timeout: config.apiTimeout * 1000
      }
    )
    
    logger.info('图像编辑API调用成功', { requestId: response.request_id })
    return response
  } catch (error) {
    logger.error('图像编辑API调用失败', error)
    throw error
  }
}
```

### 5.4 轮询状态函数（使用bot主动发送）

```typescript
async function pollImageEditStatus(
  requestId: string, 
  userId: string, 
  bot: Bot, 
  channelId: string
) {
  let attempts = 0
  
  while (attempts < config.maxPollAttempts) {
    try {
      const result = await getTaskResult(requestId)
      
      if (result.images && result.images.length > 0) {
        // 任务完成
        const userState = userStates.get(userId)
        if (userState) {
          userState.imageEditTask = null
        }
        
        logger.info('图像编辑任务完成', { 
          requestId, 
          imageCount: result.images.length
        })
        
        // 使用bot对象主动发送消息（推荐）
        await bot.sendMessage(channelId, '图像处理完成！')
        
        // 使用延时队列发送多张图片，避免刷屏
        for (const img of result.images) {
          await bot.sendMessage(channelId, h.image(img.url))
          // 如果有多张图片，添加延时
          if (result.images.length > 1) {
            await new Promise(resolve => setTimeout(resolve, 1000))
          }
        }
        
        return
      }
      
      // 继续等待
      await new Promise(resolve => setTimeout(resolve, config.pollInterval * 1000))
      attempts++
      
    } catch (error) {
      logger.error('轮询任务失败', { requestId, attempt: attempts + 1 })
      await new Promise(resolve => setTimeout(resolve, config.pollInterval * 1000))
      attempts++
    }
  }
  
  // 超时处理
  const userState = userStates.get(userId)
  if (userState) {
    userState.imageEditTask = null
  }
  
  logger.warn('图像编辑任务轮询超时', { requestId })
  
  // 使用bot对象发送超时消息
  await bot.sendMessage(channelId, '图像处理超时，请重试').catch(err => {
    logger.error('发送超时消息失败', err)
  })
}
```

### 5.5 结果查询函数

```typescript
async function getTaskResult(requestId: string) {
  try {
    const response = await ctx.http.get(
      `https://yunwu.ai/fal-ai/nano-banana/requests/${requestId}`,
      {
        headers: {
          'Authorization': `Bearer ${config.apiKey}`
        },
        timeout: config.apiTimeout * 1000
      }
    )
    
    return response
  } catch (error) {
    logger.error('查询任务结果失败', { requestId, error })
    throw error
  }
}
```

## 6. 错误处理

### 6.1 错误处理策略

```typescript
// API调用错误处理
try {
  const response = await callImageEditAPI(prompt, imageUrl, numImages)
} catch (error) {
  // 检查具体错误类型
  if (error.code === 'ETIMEDOUT') {
    return 'API请求超时，请稍后重试'
  } else if (error.response?.status === 401) {
    return 'API密钥无效，请检查配置'
  } else if (error.response?.status === 429) {
    return 'API调用频率超限，请稍后重试'
  } else if (error.response?.status === 432) {
    // 特殊处理：参数错误
    logger.error('API参数错误', { 
      status: 432, 
      response: error.response?.data 
    })
    return 'API参数错误，请联系管理员检查配置'
  } else {
    return '图像处理失败，请重试'
  }
}
```

**常见错误码**：
- `401` - API密钥无效或过期
- `429` - 请求频率超限
- `432` - 参数错误（如 `image_url` vs `image_urls`）
- `ETIMEDOUT` - 网络超时

### 6.2 超时管理（已内置）

使用 `session.prompt()` 的内置超时机制，不再需要额外的超时管理代码：

```typescript
// session.prompt() 内置超时
const msg = await session.prompt(30000)  // 30秒超时
if (!msg) {
  await session.send('等待超时')
  return null
}
```

**优势**：
- ✅ 无需手动管理超时定时器
- ✅ 自动清理等待状态
- ✅ 代码更简洁

## 7. 日志记录

使用 Koishi 内置 Logger：

```typescript
const logger = ctx.logger('aka-yunwu-figurine')

// 不同级别的日志
logger.info('图像处理插件已启动')
logger.debug('用户执行图像处理命令', { userId, prompt })
logger.success('API调用成功', { requestId })
logger.warn('任务轮询超时', { requestId })
logger.error('API调用失败', error)
```

**日志级别控制**：
```bash
# 开发环境：启用debug日志
koishi run --debug

# 生产环境：只显示info及以上级别
koishi run --log-level=2
```

## 8. 辅助命令（简化版）

### 8.1 任务状态查询

```typescript
ctx.command('图像处理.状态', '查询当前图像处理任务状态')
  .action(async ({ session }) => {
    const userId = session.userId
    const taskId = activeTasks.get(userId)
    
    if (!taskId) {
      return '当前没有图像处理任务'
    }
    
    return `图像处理任务进行中...\n任务ID: ${taskId}`
  })
```

**说明**：
- ✅ 不再需要复杂的状态判断
- ✅ 只查询activeTasks即可
- ✅ 使用子命令结构更清晰

## 9. 常见问题解决

### 9.1 API参数错误

**错误信息**：`Field required` at `["body","image_urls"]`

**原因**：
- ❌ 使用了错误的字段名 `image_url`（单数）
- ✅ 正确字段名是 `image_urls`（复数，数组类型）

**解决方案**：
```typescript
// ❌ 错误
const requestData = {
  prompt: "...",
  image_url: "https://..."  // 错误：单数且字符串
}

// ✅ 正确
const requestData = {
  prompt: "...",
  image_urls: ["https://..."]  // 正确：复数且数组
}
```

### 9.2 图片获取失败

如果图片获取失败，`getImageUrl` 函数会自动尝试三种方式，并返回 `null`。确保：
- 命令参数正确：`图像处理 [图片]`
- 引用消息包含图片
- 用户在30秒内发送图片

### 9.3 任务轮询超时

如果任务长时间未完成，检查：
- API服务是否正常
- 网络连接是否稳定
- `config.maxPollAttempts` 是否足够
- `config.pollInterval` 设置是否合理

## 10. 关键注意事项 ⚠️

### 10.1 API参数规范（重要）

**最容易出错的地方**：

| 项目 | ❌ 错误 | ✅ 正确 |
|------|---------|---------|
| 字段名 | `image_url` | `image_urls` |
| 类型 | `"string"` | `["string"]` |
| 示例 | `image_url: "https://..."` | `image_urls: ["https://..."]` |

**错误示例**：
```typescript
{
  prompt: "enhance image",
  image_url: "https://example.com/image.png",  // ❌ 错误
  num_images: 1
}
```

**正确示例**：
```typescript
{
  prompt: "enhance image",
  image_urls: ["https://example.com/image.png"],  // ✅ 正确
  num_images: 1
}
```

**原因**：
- 官方API文档明确要求 `image_urls` 字段为**数组类型**
- 即使只处理一张图片，也必须使用数组格式
- 这允许API未来支持批量处理多张图片

## 11. 总结

### 11.1 核心实现要点

**Koishi 官方方法（改进版）**：
1. ✅ 使用 `h.parse()` 解析用户消息
2. ✅ 使用 `h.select(elements, 'img')` 选择图片元素
3. ✅ 使用 `session.prompt()` 等待用户输入（内置超时）
4. ✅ 使用 `session.quote?.elements` 获取引用消息
5. ✅ 使用命令参数 `[img:text]` 支持直接传图
6. ✅ 使用 `bot.sendMessage()` 进行异步轮询时的主动消息发送
7. ✅ 使用 `ctx.logger()` 统一日志记录
8. ✅ 使用 `ctx.http` 进行HTTP请求

**功能实现**：
1. 三种方式获取图片：命令参数、引用消息、等待输入
2. 调用 `/fal-ai/nano-banana/edit` 接口进行图像编辑
3. 支持4种核心风格的图像转换，每种风格都有独立的命令和硬编码提示词
4. 支持用户自定义prompt进行图像处理，通过 `生成图像` 命令实现
5. 提示词直接硬编码在代码中，无需用户配置，确保效果一致性
6. 轮询机制使用bot对象主动发送，避免session失效
7. 多张图片发送时添加延时，避免刷屏
8. 简化的任务状态管理（只用Map跟踪任务ID）
9. 无需中间件监听，代码更简洁
10. 内置超时机制，无需手动管理定时器

### 10.2 命令使用示例

```bash
# 4个核心图像处理命令
变手办 [图片]                      # 变手办风格
变真人 [图片]                      # 变真人风格
角色设定 [图片]                    # 生成人物角色设定
二次元 [图片]                      # 新海诚风格

# 指定生成数量
变手办 [图片] -n 2                 # 生成2张手办风格图片
变真人 [图片] -n 3                 # 生成3张真人风格图片
角色设定 [图片] -n 4               # 生成4张角色设定图片
二次元 [图片] -n 2                 # 生成2张二次元风格图片

# 自定义prompt命令（新增）
生成图像                           # 使用自定义prompt
生成图像 -n 2                      # 使用自定义prompt，生成2张图片

# 自定义prompt使用方式：
# 1. 发送命令：生成图像
# 2. 系统提示：请发送图片和prompt，格式：[图片] + 你的prompt描述
# 3. 用户发送：[图片] 让这张图片变成油画风格
# 4. 系统处理并返回结果

# 方式1：命令参数传图（推荐）
变手办 [图片]
变真人 [图片] -n 2

# 方式2：引用消息
[回复包含图片的消息] 变手办
[回复包含图片的消息] 变真人 -n 2

# 方式3：等待输入
变手办
[系统提示：请在30秒内发送一张图片]
[发送图片]

# 查询状态
图像处理.状态
```

**支持的风格类型**：
- `变手办` - 手办/模型风格
- `变真人` - 真人/写实风格
- `角色设定` - 人物角色设定
- `二次元` - 新海诚风格
- `生成图像` - 用户自定义prompt风格

### 10.3 配置建议

开发环境配置：
```typescript
{
  apiKey: 'your-api-key',
  apiTimeout: 30,
  pollInterval: 3,
  maxPollAttempts: 20,
  defaultNumImages: 1
}
```

生产环境配置：
```typescript
{
  apiKey: 'your-api-key',
  apiTimeout: 60,
  pollInterval: 5,
  maxPollAttempts: 30,
  defaultNumImages: 1
}
```

**配置说明**：
- `apiKey`: 云雾API密钥（必填）
- `apiTimeout`: API请求超时时间（秒）
- `pollInterval`: 轮询间隔时间（秒）
- `maxPollAttempts`: 最大轮询次数
- `defaultNumImages`: 默认生成图片数量（1-4）

**提示词管理**：
- 所有风格的提示词都硬编码在代码中，无需用户配置
- 如需修改提示词，直接修改代码中的 `stylePrompts` 对象
- 每个命令对应一个固定的提示词，确保效果一致性
